---
title: Events, Pattern Matching, Maybe, Dict e implementando a l√≥gica do conversor
date: "2020-03-04T00:00:02Z"
keywords: tutorial de elm, tutorial de elmlang, elm, elmlang, como aprender elm, elm na pratica, aprender elm, como aprender elm, elm para iniciantes
description: Aprenda a tornar sua aplica√ß√£o interativa utilizando Events e o poder do patern matching.
category: Elm
categorySlug: elm
serie: Elm na pr√°tica
serieSlug: elm-na-pratica
episode: 3
---
Chegamos na terceira parte dessa s√©rie de tutoriais sobre Elm, e hoje finalmente vamos implementar a l√≥gica da nossa aplica√ß√£o. O c√≥digo dos tutoriais anteriores est√° dispon√≠vel nesse link: https://ellie-app.com/88hXjYRzqbwa1.

Continuando nosso conversor, hoje vamos implementar o c√°lculo da convers√£o e para isso vamos aprender algumas coisas novas: O pacote `Html.Events`, `Pattern Matching`, `Result` e `Dict`.

## Definindo as a√ß√µes do usu√°rio

Antes de tudo vamos precisar definir quais s√£o as a√ß√µes que o usu√°rio poder√° executar dentro da aplica√ß√£o, por enquanto ele poder√°:

- Alterar a moeda de origem
- Alterar a moeda de destino
- Alterar a quantia que ser√° convertido
- Clicar para calcular

Agora vamos criar uma mensagem (a partir de agora vou chamar mensagem de `msg`, √© uma abrevia√ß√£o adotada por toda a comunidade de desenvolvedores Elm) para cada uma dessas a√ß√µes, para isso vamos criar um **Custom Type**.

### Custom Type

Ainda n√£o entramos de cabe√ßa no assunto tipos mas falando sem dar muitos detalhes, no Elm temos v√°rios tipos predefinidos, por exemplo: `Boolean`, `Int`, `Float`, `String`, `List`, e n√≥s tamb√©m podemos criar nossos pr√≥prios tipos sempre que for necess√°rio, dando um exemplo simples, se quisermos criar nosso pr√≥prio tipo booleano poderiamos fazer dessa forma:

```elm
type Booleano = Verdadeiro | Falso
```

Viu como √© simples? Em um **Custom Type** n√≥s definimos quais s√£o os poss√≠veis valores que ele pode assumir, separados por uma barra vertical `|`. Aqui vai mais um exemplo pra deixar mais claro:

```elm
--   <nome do tipo>  = <valor 1> | <valor 2> | <valor 3> | <valor 4> | <valor 5>
type Animal          = Dog       | Cat       | Cow       | Duck      | Fox
```

Agora mais um detalhe sobre os **Custom Types**, podemos associar dados √† suas varia√ß√µes. Por exemplo, poderiamos descrever o progresso de uma requisi√ß√£o HTTP dessa maneira:

```elm
type HttpProgress
    = NotAsked
    | InProgress
    | Success Data
    | Error String
```

Presta aten√ß√£o nos dois √∫ltimos valores, eles possuem um tipo ap√≥s o nome do valor, isso quer dizer que a varia√ß√£o`Success` possui um valor do tipo `Data` e a varia√ß√£o `Error` possui um valor do tipo `String` que nesse caso pode ser uma mensagem de erro. Por exemplos:

```elm
Success { username = "john.doe", lastName = "Doe" }
Error "Something went wrong and we couldn't find the user"
```

J√° entendeu onde quero chegar? Se voc√™ pensou que vamos criar um tipo para a nossa `msg`, parab√©ns, voc√™ est√° certo. Ent√£o vamos l√°:

```diff
init =
    { from = "BRL"
    , to = "EUR"
    , amount = 0
    , result = 0
    }

+ type Msg
+       = ChangeOriginCurrency String
+       | ChangeDestinyCurrency String
+       | ChangeAmount String
+       | SubmitForm

update msg model =
    model
```

Aqui definimos que nossa `Msg` pode assumir 4 poss√≠veis valores:

- `ChangeOriginCurrency`: Alterar a moeda de origem
- `ChangeDestinyCurrency`: Alterar a moeda de destino
- `ChangeAmount`: Alterar a quantia que ser√° convertida
- `FormSubmitted`: Clicar para calcular

`ChangeOriginCurrency`, `ChangeDestinyCurrency` e `ChangeAmount` v√£o receber o valor dos seus respectivos inputs.

## Coletando o input do usu√°rio

Antes de tudo vamos precisar coletar  as informa√ß√µes que o usu√°rio inseriu no formul√°rio, para isso iremos utilizar a biblioteca `Html.Events`, √© ela que possui fun√ß√µes como `onClick`, `onInput`, `onSubmit` e v√°rias outras. Vamos come√ßar importando o `onInput` e `onSubmit`:

```diff
module Main exposing (main)

import Browser
import Html exposing (..)
import Html.Attributes exposing (class, type_, value, selected)
+ import Html.Events exposing (onInput, onSubmit)
```

N√≥s utilizamos os `Events` da mesma forma que os `Attributes`, passando eles na lista do primeiro argumento de uma tag HTML. Esses eventos precisam de um par√¢metro que ser√° a `msg` a ser enviada para a fun√ß√£o `update`, vamos come√ßar adicionar o evento de `onInput` no campo de moeda de origem e passaremos a mensagem `ChangeOriginCurrency`:

```diff
[ label [ class "block text-gray-700 text-sm font-bold mb-2" ] [ text "Moeda de origem" ]
  , div [ class "relative" ]
  [ select
-   [ class selectClasses, value model.from ]
+   [ class selectClasses, value model.from, onInput ChangeOriginCurrency ]
    [ option [ value "BRL", selected (model.from == "BRL") ] [ text "Real" ] 
      , option [ value "USD", selected (model.from == "USD") ] [ text "D√≥lar americano" ]
      , option [ value "EUR", selected (model.from == "EUR") ] [ text "Euro" ] 
    ]
  ]
]

```

Talvez voc√™ tenha percebido que n√£o passamos nenhum par√¢metro para a `msg` `ChangeOriginCurrency`, isso se deve ao fato de que o `onInput` vai fazer isso para n√≥s automaticamente. Agora vamos checar se isso est√° funcionando, vamos mudar o valor da moeda de origem e utilizar o debugger para ver se a mensagem foi emitida:

![](/images/elm-na-pratica-3/image-1.gif)

O valor do input da moeda de origem n√£o mudou quando selecionamos outra moeda, isso aconteceu por qu√™ ainda n√£o implementamos isso na fun√ß√£o `update` mas quando abrimos o **Debugger** (no menu superior direto) vimos que a mensagem foi enviada, e observe que a barra lateral esquerda mostra as duas mensagens que foram emitidas por que mudamos a moeda duas vezes.

![](/images/elm-na-pratica-3/image-2.png)

Agora vamos adicionar as outras mensagens no nosso HTML para finalmente implementar o `update`.

**Adicionando a mensagem de submit no formul√°rio:**

```diff
-, form [ class "bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4" ]
+, form [ onSubmit SubmitForm, class "bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4" ]
```

**Adicionando a mensagem no input da moeda de destino**:

```diff
[ label [ class "block text-gray-700 text-sm font-bold mb-2" ]
    [ text "Moeda de destino"
    ]
, div [ class "relative" ]
    [ select
-       [ class selectClasses, value model.to ]
+       [ class selectClasses, value model.to, onInput ChangeDestinyCurrency ]
        [ option [ value "USD", selected (model.to == "USD") ] [ text "D√≥lar americano" ]
        , option [ value "BRL", selected (model.to == "BRL") ] [ text "Real" ]
        , option [ value "EUR", selected (model.to == "EUR") ] [ text "Euro" ]
        ]
    ]
]
```

**Adicionando a mensagem no input da quantia a ser convertida:**

```diff
[ label [ class "block text-gray-700 text-sm font-bold mb-2" ]
    [ text "Quantidade"
    ]
-, input [ type_ "number", value (String.fromFloat model.amount), class "shadow appearence-none border rounded w-full py-2 px-3 text-gray" ] []
+, input [ type_ "number", onInput ChangeAmount, value (String.fromFloat model.amount), class "shadow appearence-none border rounded w-full py-2 px-3 text-gray" ] []
]
```

C√≥digo at√© agora: https://ellie-app.com/88LQtVdRPxka1.

## Implementando a fun√ß√£o update

Agora que todos os eventos est√£o no lugar, chegou o t√£o esperado momento de implementar o `update`, ent√£o vamos l√¢:

```diff
update msg model =
-   model
+   case msg of
+       ChangeOriginCurrency currencyCode ->
+           { model | from = currencyCode }
+
+       ChangeDestinyCurrency currencyCode ->
+           { model | to = currencyCode }
+
+       ChangeAmount amount ->
+           { model | amount = amount }
```

Aha! Achou que n√£o iriamos aprender nada novo? Te apresento o **Pattern Matching**.

### Pattern Matching

O Pattern Matching est√° bem presente nas linguagens funcionais, no Elm ele aparece na forma `case ... of` e nos possibilita tratar diferentes "branchs" (possibilidades)  de um determinado valor. Aqui vai um exemplo:

```elm
type Animal = Dog | Cat | Cow | Duck | Fox

makeSound animal =
    case animal of
        Dog -> "woof"
        Cat -> "meow"
        Cow -> "moo"
        Duck -> "quack"
```

A sintaxe n√£o √© muito complexa, iniciamos com `case <nome da vari√°vel> of` e em seguida listamos cada poss√≠vel valor e ap√≥s a seta (`->`) podemos retornar algo baseado no valor.

Um fato muito importante sobre o `case ... of` √© que voc√™ obrigat√≥riamente precisa tratar todos os poss√≠veis casos, se tentarmos compilar o c√≥digo acima, o compilador vai nos avisar que esquecemos de tratar um dos possiveis valores (`Fox`):

![](/images/elm-na-pratica-3/image-3.png)

Isso √© uma das coisas que contribuem para que uma aplica√ß√£o Elm nunca cause erros enquanto est√° sendo executada, o compilador faz com que seja imposs√≠vel deixar pontas soltas. Para corrigir isso basta adicionar a "branch" que n√£o foi tratada:

```diff
type Animal = Dog | Cat | Cow | Duck | Fox

makeSound animal =
    case animal of
        Dog -> "woof"
        Cat -> "meow"
        Cow -> "moo"
        Duck -> "quack"
+       Fox -> "Ring-ding-ding-ding-dingeringeding!"
```

O uso do `case ... of` n√£o se limita a Custom Types, pode ser utilizado com v√°rios outros tipos, como **String**, **List**, **Dict** e v√°rios outros.

Com o `case .. of` tamb√©m conseguimos acessar os valores associados a uma determinada branch, como fizemos com o nosso `update`:

```elm
update msg model =
    case msg of
    -- Nome da mensagem    Valor associado
    --       |                   |
    --       v                   V
        ChangeOriginCurrency currencyCode ->
    --                           ^
    --                           |
    --            Aqui embaixo utilizamos esse valor
    --                           |
    --                           V
            { model | from = currencyCode }
```

Agora voltando ao nosso c√≥digo (que no momento est√° assim: https://ellie-app.com/88MrJPM5Bmza1), se tentarmos compilar receberemos o seguinte erro:

![](/images/elm-na-pratica-3/image-4.png)

O compilador est√° dizendo que estamos definindo o `amount` com um valor do tipo `String` *[1]* mas que na verdade o `amount` √© do tipo `Float` *[2]*. No final *[3]* do erro ele nos d√° uma dica: "***Quer converter uma String para Float? Use a fun√ß√£o `String.toFloat`!***". Perfeito! Era justamente isso que a gente precisava. De fato n√£o estavamos convertendo os valores, observe o trecho seguinte:

```elm
ChangeAmount amount ->
    { model | amount = amount }
```

O `ChangeAmount` nos tr√°s o valor como `String` por que √© o que recebemos do `input`, logo precisaremos converter o amount para `Float` utilizando a fun√ß√£o `String.toFloat`. Ent√£o vamos nessa:

```diff
update msg model =
    case msg of
        ChangeOriginCurrency currencyCode ->
            { model | from = currencyCode }

        ChangeDestinyCurrency currencyCode ->
            { model | to = currencyCode }

        ChangeAmount amount ->
-            { model | amount = amount }
+            { model | amount = String.toFloat amount }
```

Agora deve dar tudo certo n√©? Errado! Repara na mensagem de erro:

![](/images/elm-na-pratica-3/image-5.png)

Novamente os tipos n√£o combinam, dessa vez estamos passando o tipo `Maybe Float` *[1]* mas o esperado √© `Float` *[2]*. Mais uma coisa nova pra voc√™, o tipo **Maybe**.

### Entendendo o Maybe

O **Maybe** √© um tipo que representa um valor que talvez n√£o exista. Ficou meio confuso n√©? Deixa eu dar alguns exemplos de "valores que talvez n√£o existam":

- **Pegar o primeiro item de uma lista de n√∫meros**: O resultado dessa opera√ß√£o deve ser representado por um **Maybe** pois existe a possibilidade da lista n√£o possuir o primeiro item, por exemplo quando ela estiver vazia.
- **Pegar o √∫ltimo item de uma lista de n√∫meros**: Mesma coisa do exemplo anterior, se a lista estiver vazia n√£o existir√° o √∫ltimo item, logo, o resultado deve ser representado por um **Maybe**.
- **Converter uma String para Float**: Aqui √© o caso que estamos enfrentando, existe a possibilidade de uma String n√£o ser convertida para Float. Alguns exemplos:
  - "`10"`: pode ser convertido pois representa um n√∫mero
  - `"Dez"`, "Elm": n√£o pode ser convertido pois n√£o √© um n√∫mero.

Percebeu o quanto esse tipo √© importante? O **Maybe** possui duas branchs: `Just value` e `Nothing`:

```elm
type Maybe a = Just a | Nothing
```

Isso significa que um **Maybe** pode ter um valor (`Just`) ou nada (`Nothing`). Alguns exemplos para fixar melhor:

- Primeiro item da lista `[]` (vazia): `Nothing`
- Primeiro item da lista `[1, 2, 3, 4]`: `Just 1`
- Convertendo `"Elm"` para float: `Nothing`
- Convertendo `"10"` para float: `Just 10`

Podemos pegar o valor de um **Maybe** utilizando o `case .. of`:

```elm
case (String.toFloat "10") of
    Just value ->
        "O valor √© " ++ (String.fromFloat value)
    Nothing ->
        "O resultado da convers√£o √© inv√°lido."
```

Agora voltando ao nosso conversor, vamos tratar o `Maybe Float`:

```diff
update msg model =
    case msg of
        ChangeOriginCurrency currencyCode ->
            { model | from = currencyCode }

        ChangeDestinyCurrency currencyCode ->
            { model | to = currencyCode }

        ChangeAmount amount ->
-            { model | amount = String.toFloat amount }
+            case String.toFloat amount of
+               Just value ->
+                   { model | amount = value }
+               Nothing ->
+                   model
```

Neste caso, se receber-mos `Nothing` n√£o faremos nada e retornaremos a model sem modifica√ß√µes.

Agora clique para compilar, provavelmente n√£o vai funciona pois n√£o implementamos o `SubmitForm`.

![](/images/elm-na-pratica-3/image-6.png)

O c√≥digo atualizado est√° aqui: https://ellie-app.com/88MZ6t4bmnba1.

## Calculando a convers√£o

Chegamos na √∫ltima e principal fun√ß√£o da nossa aplica√ß√£o, agora vamos implementar a convers√£o das moedas. 

Antes de tudo, precisamos dos valores das moedas, at√© agora n√£o temos eles. Pra facilitar as coisas vamos inventar uma vari√°vel com alguns valores fict√≠cios. Para isso vou utilizar uma estrutura de dados do tipo `Dict` para nos auxiliar.

### Entendendo o Dict

O **Dict** √© bem parecido com o **Record** que aprendemos no tutorial anterior. Ele possui chaves e valores mas suas chaves podem ser do tipo `Int`, `Float`, `Time`, `Char`, `String` e alguns outros.

Podemos criar um Dict dessa forma:

```elm
myDict =
    Dict.fromList [ ("chave1", 1), ("chave2", 2) ]
```

E temos fun√ß√µes para inserir, atualizar, e recuperar valores dele:

```elm
Dict.insert "chave3" 3 myDict
Dict.remove "chave3" myDict
Dict.get "chave3" myDict -- vai retornar um Maybe pois √© poss√≠vel que a chave n√£o exista no Dict
```

Agora vamos criar algumas vari√°veis para as nossas moedas utilizando o **Dict**, primeiro vamos importar o m√≥dulo:

```diff
module Main exposing (main)

import Browser
+ import Dict
import Html exposing (..)
import Html.Attributes exposing (class, selected, type_, value)
import Html.Events exposing (onInput, onSubmit)
```

Em seguida vamos criar as vari√°veis:

```diff
selectClasses =
    "block appearance-none w-full border shadow py-2 px-3 pr-8 rounded"

+ brl =
+     Dict.fromList
+         [ ( "EUR", 0.21 )
+         , ( "USD", 0.23 )
+         ]
+
+ usd =
+     Dict.fromList
+         [ ( "EUR", 0.92 )
+         , ( "BRL", 4.42 )
+         ]
+
+ eur =
+     Dict.fromList
+         [ ( "USD", 1.09 )
+         , ( "BRL", 4.81 )
+         ]
+
+ currencies =
+     Dict.fromList
+         [ ( "BRL", brl )
+         , ( "EUR", eur )
+         , ( "USD", usd )
+         ]

init =
    { from = "BRL"
    , to = "EUR"
    , amount = 0
    , result = 0
    }
```

E agora no `update` implementaremos a convers√£o da seguinte maneira:

```diff
update msg model =
    case msg of
        ChangeOriginCurrency currencyCode ->
            { model | from = currencyCode }

        ChangeDestinyCurrency currencyCode ->
            { model | to = currencyCode }

        ChangeAmount amount ->
            case String.toFloat amount of
                Just value ->
                    { model | amount = value }

                Nothing ->
                    model
+
+       SubmitForm ->
+           case Dict.get model.from currencies of
+               Just availableCurrencies ->
+                   case Dict.get model.to availableCurrencies of
+                       Just toCurrency ->
+                           { model | result = toCurrency * model.amount }
+
+                       Nothing ->
+                           model
+
+               Nothing ->
+                   model
```

**Pronto!** Copia esse c√≥digo, clica para compilar, adiciona um valor para converter e clica para converter:

![](/images/elm-na-pratica-3/image-7.gif)

Mas nem tudo s√£o flores, o c√≥digo est√° um pouco confuso n√©?

```elm
        SubmitForm ->
            -- Aqui vamos pegar os valores de convers√£o da moeda de origem
            -- Por exemplo, se `model.from` for "BRL":
            -- Dict.get "BRL" currencies
            case Dict.get model.from currencies of
                    -- Caso essa moeda exista no `currencies` teremos acesso a ela
                    -- no `Just`
                Just availableCurrencies ->
                    -- Utilizando o resultado `availableCurrencies` vamos tentar pegar o valor
                    -- da moeda destino.
                    -- Por exemplo, se `model.to` for "EUR":
                    -- Dict.get "EUR" availableCurrencies
                    case Dict.get model.to availableCurrencies of
                         -- Se conseguir-mos pegar o valor, calcular o resultado
                         -- multiplicando o valor da moeda (destinyCurrencyValue) pela
                         -- quantia a ser convertida (model.amount)
                        Just destinyCurrencyValue ->
                            { model | result = destinyCurrencyValue * model.amount }
                        -- Caso a moeda n√£o seja encontrada, iremos definir o `result` como 0
                        Nothing ->
                            { model | result = 0 }
                -- Caso a moeda n√£o seja encontrada, iremos definir o `result` como 0
                Nothing ->
                    { model | result = 0 }
```

Temos tr√™s `case .. of` aninhados e isso dificulta um pouco a legibilidade e a manuten√ß√£o do c√≥digo, ent√£o vamos melhorar isso um pouco. Fique a vontade para pegar o c√≥digo atualizado: https://ellie-app.com/88NKHgZrtQWa1.

### Utilizando o `let ... in`

O `let ... in` permite que a gente defina valores dentro de uma express√£o, assim poderemos guardar valores para utilizar depois. Por exemplo:

```elm
soma a b =
    let
        resultado = a + b
    in
        "O resultado √©: " ++ (String.fromInt resultado)
```

Agora vamos refatorar a nossa fun√ß√£o:

```diff
SubmitForm ->
-   case Dict.get model.from currencies of
-       Just availableCurrencies ->
-           case Dict.get model.to availableCurrencies of
-               Just destinyCurrencyValue ->
-                   { model | result = destinyCurrencyValue * model.amount }
-               Nothing ->
-                   model
-       Nothing ->
-           model
+ let
+     availableCurrencies =
+         Maybe.withDefault Dict.empty (Dict.get model.from currencies)
+
+     destinyCurrencyValue =
+         Maybe.withDefault 0 (Dict.get model.to availableCurrencies)
+
+     result =
+         destinyCurrencyValue * model.amount
+ in
+     { model | result = result }
```

**BEM** melhor n√£o √© mesmo? Para isso, al√©m do `let ... in` utilizei a fun√ß√£o `Maybe.withDefault` para facilitar as coisas por aqui. O `Maybe.withDefault` nos permite definir um valor padr√£o caso o segundo par√¢metro seja `Nothing`.

Aqui dizemos que o valor padr√£o para o resultado de `Dict.get model.from currencies` √© um Dict vazio (`Dict.empty`):

```elm
availableCurrencies =
    Maybe.withDefault Dict.empty (Dict.get model.from currencies)
```

Em seguida definimos que o valor padr√£o para o resultado de `Dict.get model.to availabileCurrencies` √© `0` (zero):

```elm
destinyCurrencyValue =
    Maybe.withDefault 0 (Dict.get model.to availableCurrencies)
```

E por fim calculamos o resultado e atualizamos a model:

```elm
    result =
        destinyCurrencyValue * model.amount
in
    { model | result = result }
```

Ainda d√° para melhorar esse c√≥digo mais um pouquinho mas vou deixar isso para os pr√≥ximos tutoriais.

## Conclus√£o

Finalmente implementamos todas as funcionalidades do conversor, agora ele de fato converte as moedas üéâ. Mas ainda temos v√°rios pontos para melhorar e que poderemos explorar novas APIs e conceitos do Elm.

Esse tutorial foi bastante denso e cheio de coisas novas, ent√£o n√£o fique chateado caso n√£o tenha entendido tudo, alguns desses conceitos podem demorar dias para serem de fato aprendidos. Sugiro que voc√™ tente fazer uma outra aplica√ß√£o utilizando tudo o que aprendeu at√© agora, dessa forma voc√™ ir√° escalar a curva de aprendizado do Elm bem mais r√°pido.

No pr√≥ximo tutorial iremos aprender a ler assinatura de tipos e tipar nossa aplica√ß√£o, assim o compilador ir√° nos ajudar mais. Eu particularmente estou bastante animado com o que est√° por vir.

Como sempre, o c√≥digo atualizado est√° dispon√≠vel neste link: https://ellie-app.com/88NYGqX6QzVa1 e basta [clicar aqui](/20200311-elm-na-pratica-4) para iniciar o pr√≥ximo tutorial.

At√© a pr√≥xima!
